" ___vital___
" NOTE: lines between '" ___vital___' is generated by :Vitalize.
" Do not modify the code nor insert new lines before '" ___vital___'
function! s:_SID() abort
  return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
endfunction
execute join(['function! vital#_esearch#Vim#Highlight#import() abort', printf("return map({'set': '', 'get': ''}, \"vital#_esearch#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
delfunction s:_SID
" ___vital___
function! s:get(...) abort
  let name = a:0 ? a:1 : ''
  let records = split(s:_highlight(name), '\r\?\n')
  let highlights = map(records, 's:_parse_record(v:val)')
  return a:0 ? highlights[0] : highlights
endfunction

function! s:set(name, attrs, ...) abort
  let options = extend({
        \ 'force': 0,
        \ 'default': 0,
        \}, get(a:000, 0, {})
        \)
  let force = options.force ? '!' : ''
  let default = options.default ? 'default' : ''
  if empty(a:attrs)
    execute 'highlight' 'clear' a:name
  elseif !empty(get(a:attrs, 'link'))
    execute 'highlight' . force default 'link' a:name a:attrs.link
  else
    let attrs = map(items(a:attrs), 'v:val[0] . ''='' . v:val[1]')
    execute 'highlight' default a:name join(attrs)
  endif
endfunction


function! s:_parse_record(record) abort
  let m = matchlist(a:record, '^\%(\S\+\)\s\+xxx\s\(.*\)$')
  if empty(m)
    return {}
  endif
  return s:_parse_attrs(m[1])
endfunction

function! s:_parse_attrs(attrs) abort
  if a:attrs ==# 'cleared'
    return {}
  elseif a:attrs =~# '^links to'
    return { 'link': matchstr(a:attrs, 'links to \zs.*') }
  endif
  let attrs = {}
  for term in split(a:attrs, ' ')
    let m = split(term, '=')
    if len(m) < 2
      continue
    endif
    let attrs[m[0]] = join(m[1:], '=')
  endfor
  return attrs
endfunction

function! s:_highlight(name) abort
  return execute(printf('highlight %s', a:name))
endfunction
